# Copyright (c) 2025 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/studio_topology.v1/services.gen.proto, arista/studio_topology.v1/studio_topology.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

import aristaproto
import grpclib
from aristaproto.grpc.grpclib_server import ServiceBase

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)
from ...workspace import v1 as __workspace_v1__


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class Element(aristaproto.Enum):
    """Element defines the fundamental types of elements in topology."""

    UNSPECIFIED = 0
    """ELEMENT_UNSPECIFIED indicates an unspecified element type."""

    DEVICE = 1
    """ELEMENT_DEVICE indicates a device."""

    INTERFACE = 2
    """ELEMENT_INTERFACE indicates an interface."""

    CONNECTION = 3
    """ELEMENT_CONNECTION indicates a connection."""


class Operation(aristaproto.Enum):
    """
    Operation defines the operations that may be performed on the topology.
    """

    UNSPECIFIED = 0
    """OPERATION_UNSPECIFIED indicates an unspecified operation."""

    ADDED = 1
    """OPERATION_ADDED indicates addition of an Element."""

    MODIFIED = 2
    """OPERATION_MODIFIED indicates modification of an Element."""

    REMOVED = 3
    """OPERATION_REMOVED indicates removal of an Element."""


class UpdateStatus(aristaproto.Enum):
    """
    UpdateStatus defines the set of statuses that apply to individual topology updates.
    """

    UNSPECIFIED = 0
    """UPDATE_STATUS_UNSPECIFIED indicates an unspecified update status."""

    NEW = 1
    """UPDATE_STATUS_NEW indicates the update is new."""

    ACCEPTED = 2
    """UPDATE_STATUS_ACCEPTED indicates the update is accepted."""

    IGNORED = 3
    """UPDATE_STATUS_IGNORED indicates the update is ignored."""


class DecommissionStatus(aristaproto.Enum):
    """
    DecommissionStatus enumerates the status of decommissioning a device.
    """

    UNSPECIFIED = 0
    """
    DECOMMISSION_STATUS_UNSPECIFIED indicates that the device was decommissioned with
     an unspecified state.
    """

    SUCCESS = 1
    """
    DECOMMISSION_STATUS_SUCCESS indicates that the device was successfully decommissioned.
    """

    FAILURE = 2
    """
    DECOMMISSION_STATUS_FAILURE indicates an error with decommissioning the device.
    """


@dataclass(eq=False, repr=False)
class DeviceInfo(aristaproto.Message):
    """DeviceInfo contains device properties."""

    device_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""

    model_name: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """model_name indicates the model of the device."""

    mac_address: "___fmp__.MacAddress" = aristaproto.message_field(3)
    """mac_address indicates the MAC address of the device."""

    hostname: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """hostname indicates the hostname of the device."""


@dataclass(eq=False, repr=False)
class InterfaceInfo(aristaproto.Message):
    """InterfaceInfo contains interface properties."""

    name: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """name is the name of an interface."""

    neighbor_device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """
    neighbor_device_id indicates the device ID of the neighbor to which
     this interface is connected.
    """

    neighbor_interface_name: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    neighbor_interface_name indicates the interface on the neighbor to which
     this interface is connected.
    """


@dataclass(eq=False, repr=False)
class InterfaceInfos(aristaproto.Message):
    """InterfaceInfos is a list of InterfaceInfo."""

    values: List["InterfaceInfo"] = aristaproto.message_field(1)
    """values is a list of InterfaceInfo."""


@dataclass(eq=False, repr=False)
class DeviceKey(aristaproto.Message):
    """DeviceKey uniquely identifies the device for a workspace."""

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""


@dataclass(eq=False, repr=False)
class DeviceInputConfig(aristaproto.Message):
    """DeviceInputConfig is the desired topology input for a device."""

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device ID for a given workspace."""

    device_info: "DeviceInfo" = aristaproto.message_field(2)
    """device_info contains device properties."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the device from mainline
     post workspace merge
    """


@dataclass(eq=False, repr=False)
class InterfaceInputKey(aristaproto.Message):
    """
    InterfaceInputKey is the set of inputs that uniquely identify
     the interface for a workspace.
    """

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    device_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """device_id identifies the device uniquely."""

    interface_id: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """interface_id along with device_id identifies the interface uniquely."""


@dataclass(eq=False, repr=False)
class InterfaceInputConfig(aristaproto.Message):
    """
    InterfaceInputConfig is the resource for manually adding
     an interface in I&T studios
    """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """key uniquely identifies the interface for a given workspace."""

    interface_info: "InterfaceInfo" = aristaproto.message_field(2)
    """interface_info contains interface properties."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the interface from mainline
     post workspace merge
    """


@dataclass(eq=False, repr=False)
class DeviceState(aristaproto.Message):
    """
    DeviceState is the state of a device written by
     InterfaceInputConfig, DeviceInputConfig and
     UpdateConfig resources
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device for a given workspace."""

    device_info: "DeviceInfo" = aristaproto.message_field(2)
    """device_info contains device properties"""

    interface_infos: "InterfaceInfos" = aristaproto.message_field(3)
    """
    interface_infos contains interface properties of all the interfaces
     belonging to the device
    """


@dataclass(eq=False, repr=False)
class UpdateKey(aristaproto.Message):
    """UpdateKey uniquely identifies a workspace topology update."""

    workspace_id: Optional[str] = aristaproto.message_field(
        1, wraps=aristaproto.TYPE_STRING
    )
    """workspace_id identifies the workspace uniquely."""

    update_id: Optional[str] = aristaproto.message_field(
        2, wraps=aristaproto.TYPE_STRING
    )
    """update_id identifies the update uniquely."""


@dataclass(eq=False, repr=False)
class UpdateConfig(aristaproto.Message):
    """UpdateConfig contains the acceptance status of an Update."""

    key: "UpdateKey" = aristaproto.message_field(1)
    """key uniquely identifies the update."""

    status: "UpdateStatus" = aristaproto.enum_field(2)
    """status indicates the status of the topology update."""

    remove: Optional[bool] = aristaproto.message_field(3, wraps=aristaproto.TYPE_BOOL)
    """
    remove if set to true will remove the update key from mainline
     post workspace merge. This can only be set true for ignored keys
     since we don't carry accepted keys to mainline post workspace
     merge
    """


@dataclass(eq=False, repr=False)
class Update(aristaproto.Message):
    """Update represents an update on to the workspace."""

    key: "UpdateKey" = aristaproto.message_field(1)
    """key uniquely identifies the update."""

    element: "Element" = aristaproto.enum_field(2)
    """element indicates the type of a network element."""

    operation: "Operation" = aristaproto.enum_field(3)
    """operation indicates the type of operation on the topology update."""

    status: "UpdateStatus" = aristaproto.enum_field(4)
    """status indicates the status of the topology update."""

    description: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """description describes the topology update in short."""


@dataclass(eq=False, repr=False)
class UpdateSyncConfig(aristaproto.Message):
    """
    UpdateSyncConfig model represents a point in time all updates
     are to be accepted.
    """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """key uniquely identifies the workspace."""

    sync_time: datetime = aristaproto.message_field(2)
    """
    sync_time indicates the desired synchronization time with the live topology.
     If the sync_time indicated in the config takes effect without error,
     it will appear in the state model, and then all updates that occurred up to
     and including the timestamp in the state model will be accepted.
    """


@dataclass(eq=False, repr=False)
class RevertConfig(aristaproto.Message):
    """RevertConfig is the model provided to revert a workspace."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """key uniquely identifies the workspace."""


@dataclass(eq=False, repr=False)
class DecommissionConfig(aristaproto.Message):
    """
    DecommissionConfig is the resource for decommissioning
     the device from the studio.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device for a given workspace."""


@dataclass(eq=False, repr=False)
class Decommission(aristaproto.Message):
    """
    Decommission is the resource that holds the decommissioning
     state of a device.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    """key uniquely identifies the device in a given workspace."""

    created_at: datetime = aristaproto.message_field(2)
    """created_at is the time at which decommissioning was first initiated."""

    created_by: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """
    created_by is the name of the user who first initiated decommissioning.
    """

    last_modified_at: datetime = aristaproto.message_field(4)
    """
    last_modified_at is the time at which the decommissioning was last modified.
    """

    last_modified_by: Optional[str] = aristaproto.message_field(
        5, wraps=aristaproto.TYPE_STRING
    )
    """
    last_modified_by is the name of the user that last modified the status.
    """

    status: "DecommissionStatus" = aristaproto.enum_field(6)
    """status indicates the status of the decommissioned device"""

    error: Optional[str] = aristaproto.message_field(7, wraps=aristaproto.TYPE_STRING)
    """error indicates an error message"""


@dataclass(eq=False, repr=False)
class MetaResponse(aristaproto.Message):
    time: datetime = aristaproto.message_field(1)
    """
    Time holds the timestamp of the last item included in the metadata calculation.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(2)
    """
    Operation indicates how the value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """

    count: Optional[int] = aristaproto.message_field(3, wraps=aristaproto.TYPE_UINT32)
    """
    Count is the number of items present under the conditions of the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Decommission instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionResponse(aristaproto.Message):
    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     Decommission instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionSomeResponse(aristaproto.Message):
    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DecommissionStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Decommission"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Decommission at end.
         * Each Decommission response is fully-specified (all fields set).
       * start: Returns the state of each Decommission at start, followed by updates until now.
         * Each Decommission response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Decommission at start, followed by updates
         until end.
         * Each Decommission response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DecommissionStreamResponse(aristaproto.Message):
    value: "Decommission" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Decommission's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Decommission value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DecommissionBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Decommission"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Decommission at end.
         * Each Decommission response is fully-specified (all fields set).
       * start: Returns the state of each Decommission at start, followed by updates until now.
         * Each Decommission response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Decommission at start, followed by updates
         until end.
         * Each Decommission response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DecommissionBatchedStreamResponse(aristaproto.Message):
    responses: List["DecommissionStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DecommissionConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigResponse(aristaproto.Message):
    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DecommissionConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSomeResponse(aristaproto.Message):
    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DecommissionConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DecommissionConfig at end.
         * Each DecommissionConfig response is fully-specified (all fields set).
       * start: Returns the state of each DecommissionConfig at start, followed by updates until now.
         * Each DecommissionConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DecommissionConfig at start, followed by updates
         until end.
         * Each DecommissionConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigStreamResponse(aristaproto.Message):
    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DecommissionConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DecommissionConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DecommissionConfig at end.
         * Each DecommissionConfig response is fully-specified (all fields set).
       * start: Returns the state of each DecommissionConfig at start, followed by updates until now.
         * Each DecommissionConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DecommissionConfig at start, followed by updates
         until end.
         * Each DecommissionConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["DecommissionConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetRequest(aristaproto.Message):
    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    DecommissionConfig carries the value to set into the datastore.
     See the documentation on the DecommissionConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetResponse(aristaproto.Message):
    value: "DecommissionConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DecommissionConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetSomeRequest(aristaproto.Message):
    values: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DecommissionConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigSetSomeResponse(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key indicates which DecommissionConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteResponse(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted DecommissionConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """key contains a list of DecommissionConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteSomeResponse(aristaproto.Message):
    """
    DecommissionConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["DecommissionConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DecommissionConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceKey" = aristaproto.message_field(3)
    """
    This is the key of the DecommissionConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceInputConfigRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceInputConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigResponse(aristaproto.Message):
    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSomeResponse(aristaproto.Message):
    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceInputConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceInputConfig at end.
         * Each DeviceInputConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceInputConfig at start, followed by updates until now.
         * Each DeviceInputConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceInputConfig at start, followed by updates
         until end.
         * Each DeviceInputConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigStreamResponse(aristaproto.Message):
    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceInputConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceInputConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceInputConfig at end.
         * Each DeviceInputConfig response is fully-specified (all fields set).
       * start: Returns the state of each DeviceInputConfig at start, followed by updates until now.
         * Each DeviceInputConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceInputConfig at start, followed by updates
         until end.
         * Each DeviceInputConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceInputConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetRequest(aristaproto.Message):
    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    DeviceInputConfig carries the value to set into the datastore.
     See the documentation on the DeviceInputConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetResponse(aristaproto.Message):
    value: "DeviceInputConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceInputConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetSomeRequest(aristaproto.Message):
    values: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    value contains a list of DeviceInputConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigSetSomeResponse(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceInputConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteResponse(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted DeviceInputConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    """key contains a list of DeviceInputConfig keys to delete"""


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteSomeResponse(aristaproto.Message):
    """
    DeviceInputConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "DeviceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class DeviceInputConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceInputConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceStateRequest(aristaproto.Message):
    key: "DeviceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceState instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceStateResponse(aristaproto.Message):
    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceState instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceStateSomeRequest(aristaproto.Message):
    keys: List["DeviceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceStateSomeResponse(aristaproto.Message):
    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class DeviceStateStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceState"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceState at end.
         * Each DeviceState response is fully-specified (all fields set).
       * start: Returns the state of each DeviceState at start, followed by updates until now.
         * Each DeviceState response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceState at start, followed by updates
         until end.
         * Each DeviceState response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceStateStreamResponse(aristaproto.Message):
    value: "DeviceState" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this DeviceState's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceState value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceStateBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceState"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each DeviceState at end.
         * Each DeviceState response is fully-specified (all fields set).
       * start: Returns the state of each DeviceState at start, followed by updates until now.
         * Each DeviceState response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each DeviceState at start, followed by updates
         until end.
         * Each DeviceState response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class DeviceStateBatchedStreamResponse(aristaproto.Message):
    responses: List["DeviceStateStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigRequest(aristaproto.Message):
    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a InterfaceInputConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigResponse(aristaproto.Message):
    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     InterfaceInputConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSomeRequest(aristaproto.Message):
    keys: List["InterfaceInputKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSomeResponse(aristaproto.Message):
    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class InterfaceInputConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each InterfaceInputConfig at end.
         * Each InterfaceInputConfig response is fully-specified (all fields set).
       * start: Returns the state of each InterfaceInputConfig at start, followed by updates until now.
         * Each InterfaceInputConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each InterfaceInputConfig at start, followed by updates
         until end.
         * Each InterfaceInputConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigStreamResponse(aristaproto.Message):
    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceInputConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the InterfaceInputConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each InterfaceInputConfig at end.
         * Each InterfaceInputConfig response is fully-specified (all fields set).
       * start: Returns the state of each InterfaceInputConfig at start, followed by updates until now.
         * Each InterfaceInputConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each InterfaceInputConfig at start, followed by updates
         until end.
         * Each InterfaceInputConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["InterfaceInputConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetRequest(aristaproto.Message):
    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    InterfaceInputConfig carries the value to set into the datastore.
     See the documentation on the InterfaceInputConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetResponse(aristaproto.Message):
    value: "InterfaceInputConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the InterfaceInputConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetSomeRequest(aristaproto.Message):
    values: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    value contains a list of InterfaceInputConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigSetSomeResponse(aristaproto.Message):
    key: "InterfaceInputKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteRequest(aristaproto.Message):
    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key indicates which InterfaceInputConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteResponse(aristaproto.Message):
    key: "InterfaceInputKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted InterfaceInputConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["InterfaceInputKey"] = aristaproto.message_field(1)
    """key contains a list of InterfaceInputConfig keys to delete"""


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteSomeResponse(aristaproto.Message):
    """
    InterfaceInputConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "InterfaceInputKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceInputConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class InterfaceInputConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "InterfaceInputKey" = aristaproto.message_field(3)
    """
    This is the key of the InterfaceInputConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class RevertConfigRequest(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a RevertConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class RevertConfigResponse(aristaproto.Message):
    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     RevertConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSomeRequest(aristaproto.Message):
    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSomeResponse(aristaproto.Message):
    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class RevertConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each RevertConfig at end.
         * Each RevertConfig response is fully-specified (all fields set).
       * start: Returns the state of each RevertConfig at start, followed by updates until now.
         * Each RevertConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each RevertConfig at start, followed by updates
         until end.
         * Each RevertConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class RevertConfigStreamResponse(aristaproto.Message):
    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this RevertConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the RevertConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class RevertConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each RevertConfig at end.
         * Each RevertConfig response is fully-specified (all fields set).
       * start: Returns the state of each RevertConfig at start, followed by updates until now.
         * Each RevertConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each RevertConfig at start, followed by updates
         until end.
         * Each RevertConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class RevertConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["RevertConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetRequest(aristaproto.Message):
    value: "RevertConfig" = aristaproto.message_field(1)
    """
    RevertConfig carries the value to set into the datastore.
     See the documentation on the RevertConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetResponse(aristaproto.Message):
    value: "RevertConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the RevertConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetSomeRequest(aristaproto.Message):
    values: List["RevertConfig"] = aristaproto.message_field(1)
    """
    value contains a list of RevertConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class RevertConfigSetSomeResponse(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class RevertConfigDeleteRequest(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key indicates which RevertConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteResponse(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted RevertConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """key contains a list of RevertConfig keys to delete"""


@dataclass(eq=False, repr=False)
class RevertConfigDeleteSomeResponse(aristaproto.Message):
    """RevertConfigDeleteSomeResponse is only sent when there is an error."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class RevertConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["RevertConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class RevertConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(3)
    """
    This is the key of the RevertConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class UpdateRequest(aristaproto.Message):
    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a Update instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateResponse(aristaproto.Message):
    value: "Update" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     Update instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateSomeRequest(aristaproto.Message):
    keys: List["UpdateKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSomeResponse(aristaproto.Message):
    value: "Update" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Update"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Update at end.
         * Each Update response is fully-specified (all fields set).
       * start: Returns the state of each Update at start, followed by updates until now.
         * Each Update response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Update at start, followed by updates
         until end.
         * Each Update response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class UpdateStreamResponse(aristaproto.Message):
    value: "Update" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this Update's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the Update value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["Update"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each Update at end.
         * Each Update response is fully-specified (all fields set).
       * start: Returns the state of each Update at start, followed by updates until now.
         * Each Update response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each Update at start, followed by updates
         until end.
         * Each Update response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateBatchedStreamResponse(aristaproto.Message):
    responses: List["UpdateStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateConfigRequest(aristaproto.Message):
    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a UpdateConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigResponse(aristaproto.Message):
    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     UpdateConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSomeRequest(aristaproto.Message):
    keys: List["UpdateKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSomeResponse(aristaproto.Message):
    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each UpdateConfig at end.
         * Each UpdateConfig response is fully-specified (all fields set).
       * start: Returns the state of each UpdateConfig at start, followed by updates until now.
         * Each UpdateConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each UpdateConfig at start, followed by updates
         until end.
         * Each UpdateConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigStreamResponse(aristaproto.Message):
    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this UpdateConfig's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the UpdateConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each UpdateConfig at end.
         * Each UpdateConfig response is fully-specified (all fields set).
       * start: Returns the state of each UpdateConfig at start, followed by updates until now.
         * Each UpdateConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each UpdateConfig at start, followed by updates
         until end.
         * Each UpdateConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["UpdateConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetRequest(aristaproto.Message):
    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    UpdateConfig carries the value to set into the datastore.
     See the documentation on the UpdateConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetResponse(aristaproto.Message):
    value: "UpdateConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the UpdateConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetSomeRequest(aristaproto.Message):
    values: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    value contains a list of UpdateConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigSetSomeResponse(aristaproto.Message):
    key: "UpdateKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteRequest(aristaproto.Message):
    key: "UpdateKey" = aristaproto.message_field(1)
    """
    Key indicates which UpdateConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteResponse(aristaproto.Message):
    key: "UpdateKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted UpdateConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["UpdateKey"] = aristaproto.message_field(1)
    """key contains a list of UpdateConfig keys to delete"""


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteSomeResponse(aristaproto.Message):
    """UpdateConfigDeleteSomeResponse is only sent when there is an error."""

    key: "UpdateKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class UpdateConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "UpdateKey" = aristaproto.message_field(3)
    """
    This is the key of the UpdateConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class UpdateSyncConfigRequest(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a UpdateSyncConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigResponse(aristaproto.Message):
    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     UpdateSyncConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSomeRequest(aristaproto.Message):
    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSomeResponse(aristaproto.Message):
    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """
    Error is an optional field.
     It should be filled when there is an error in the GetSome process.
    """

    time: datetime = aristaproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateSyncConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each UpdateSyncConfig at end.
         * Each UpdateSyncConfig response is fully-specified (all fields set).
       * start: Returns the state of each UpdateSyncConfig at start, followed by updates until now.
         * Each UpdateSyncConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each UpdateSyncConfig at start, followed by updates
         until end.
         * Each UpdateSyncConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigStreamResponse(aristaproto.Message):
    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this UpdateSyncConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the UpdateSyncConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigBatchedStreamRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     For GetAll, the fields start and end can be used as follows:

       * end: Returns the state of each UpdateSyncConfig at end.
         * Each UpdateSyncConfig response is fully-specified (all fields set).
       * start: Returns the state of each UpdateSyncConfig at start, followed by updates until now.
         * Each UpdateSyncConfig response at start is fully-specified, but updates may be partial.
       * start and end: Returns the state of each UpdateSyncConfig at start, followed by updates
         until end.
         * Each UpdateSyncConfig response at start is fully-specified, but updates until end may
           be partial.

     This field is not allowed in the Subscribe RPC.
    """

    max_messages: Optional[int] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_UINT32
    )
    """
    MaxMessages limits the maximum number of messages that can be contained in one batch.
     MaxMessages is required to be at least 1.
     The maximum number of messages in a batch is min(max_messages, INTERNAL_BATCH_LIMIT)
     INTERNAL_BATCH_LIMIT is set based on the maximum message size.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigBatchedStreamResponse(aristaproto.Message):
    responses: List["UpdateSyncConfigStreamResponse"] = aristaproto.message_field(1)
    """
    Values are the values deemed relevant to the initiating request.
     The length of this structure is guaranteed to be between (inclusive) 1 and
     min(req.max_messages, INTERNAL_BATCH_LIMIT).
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetRequest(aristaproto.Message):
    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    UpdateSyncConfig carries the value to set into the datastore.
     See the documentation on the UpdateSyncConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetResponse(aristaproto.Message):
    value: "UpdateSyncConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the UpdateSyncConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetSomeRequest(aristaproto.Message):
    values: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    value contains a list of UpdateSyncConfig values to write.
     It is possible to provide more values than can fit within either:
         - the maxiumum send size of the client
         - the maximum receive size of the server
     If this error occurs you must reduce the number of values sent.
     See gRPC "maximum message size" documentation for more information.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigSetSomeResponse(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteRequest(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """
    Key indicates which UpdateSyncConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteResponse(aristaproto.Message):
    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted UpdateSyncConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteSomeRequest(aristaproto.Message):
    keys: List["__workspace_v1__.WorkspaceKey"] = aristaproto.message_field(1)
    """key contains a list of UpdateSyncConfig keys to delete"""


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteSomeResponse(aristaproto.Message):
    """
    UpdateSyncConfigDeleteSomeResponse is only sent when there is an error.
    """

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(1)
    error: str = aristaproto.string_field(2)


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteAllRequest(aristaproto.Message):
    partial_eq_filter: List["UpdateSyncConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a DeleteAll.
     This requires all provided fields to be equal to the response.
     A filtered DeleteAll will use GetAll with filter to find things to delete.
    """


@dataclass(eq=False, repr=False)
class UpdateSyncConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """
    This describes the class of delete error.
     A DeleteAllResponse is only sent when there is an error.
    """

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "__workspace_v1__.WorkspaceKey" = aristaproto.message_field(3)
    """
    This is the key of the UpdateSyncConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class DecommissionServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        decommission_request: "DecommissionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DecommissionResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionService/GetOne",
            decommission_request,
            DecommissionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        decommission_some_request: "DecommissionSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetSome",
            decommission_some_request,
            DecommissionSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetAll",
            decommission_stream_request,
            DecommissionStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/Subscribe",
            decommission_stream_request,
            DecommissionStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionService/GetMeta",
            decommission_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        decommission_stream_request: "DecommissionStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/SubscribeMeta",
            decommission_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        decommission_batched_stream_request: "DecommissionBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/GetAllBatched",
            decommission_batched_stream_request,
            DecommissionBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        decommission_batched_stream_request: "DecommissionBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionService/SubscribeBatched",
            decommission_batched_stream_request,
            DecommissionBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DecommissionConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        decommission_config_request: "DecommissionConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DecommissionConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/GetOne",
            decommission_config_request,
            DecommissionConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        decommission_config_some_request: "DecommissionConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetSome",
            decommission_config_some_request,
            DecommissionConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetAll",
            decommission_config_stream_request,
            DecommissionConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/Subscribe",
            decommission_config_stream_request,
            DecommissionConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/GetMeta",
            decommission_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        decommission_config_stream_request: "DecommissionConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeMeta",
            decommission_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        decommission_config_set_request: "DecommissionConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DecommissionConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/Set",
            decommission_config_set_request,
            DecommissionConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        decommission_config_set_some_request: "DecommissionConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SetSome",
            decommission_config_set_some_request,
            DecommissionConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        decommission_config_delete_request: "DecommissionConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DecommissionConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DecommissionConfigService/Delete",
            decommission_config_delete_request,
            DecommissionConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        decommission_config_delete_some_request: "DecommissionConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteSome",
            decommission_config_delete_some_request,
            DecommissionConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        decommission_config_delete_all_request: "DecommissionConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteAll",
            decommission_config_delete_all_request,
            DecommissionConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/GetAllBatched",
            decommission_config_batched_stream_request,
            DecommissionConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DecommissionConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeBatched",
            decommission_config_batched_stream_request,
            DecommissionConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceInputConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_input_config_request: "DeviceInputConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceInputConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetOne",
            device_input_config_request,
            DeviceInputConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_input_config_some_request: "DeviceInputConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetSome",
            device_input_config_some_request,
            DeviceInputConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAll",
            device_input_config_stream_request,
            DeviceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/Subscribe",
            device_input_config_stream_request,
            DeviceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetMeta",
            device_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_input_config_stream_request: "DeviceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeMeta",
            device_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_input_config_set_request: "DeviceInputConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceInputConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/Set",
            device_input_config_set_request,
            DeviceInputConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        device_input_config_set_some_request: "DeviceInputConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SetSome",
            device_input_config_set_some_request,
            DeviceInputConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        device_input_config_delete_request: "DeviceInputConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceInputConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceInputConfigService/Delete",
            device_input_config_delete_request,
            DeviceInputConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        device_input_config_delete_some_request: "DeviceInputConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteSome",
            device_input_config_delete_some_request,
            DeviceInputConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        device_input_config_delete_all_request: "DeviceInputConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteAll",
            device_input_config_delete_all_request,
            DeviceInputConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAllBatched",
            device_input_config_batched_stream_request,
            DeviceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceInputConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeBatched",
            device_input_config_batched_stream_request,
            DeviceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceStateServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_state_request: "DeviceStateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceStateResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceStateService/GetOne",
            device_state_request,
            DeviceStateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        device_state_some_request: "DeviceStateSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStateSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetSome",
            device_state_some_request,
            DeviceStateSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetAll",
            device_state_stream_request,
            DeviceStateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/Subscribe",
            device_state_stream_request,
            DeviceStateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.DeviceStateService/GetMeta",
            device_state_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        device_state_stream_request: "DeviceStateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/SubscribeMeta",
            device_state_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        device_state_batched_stream_request: "DeviceStateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/GetAllBatched",
            device_state_batched_stream_request,
            DeviceStateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        device_state_batched_stream_request: "DeviceStateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceStateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.DeviceStateService/SubscribeBatched",
            device_state_batched_stream_request,
            DeviceStateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceInputConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        interface_input_config_request: "InterfaceInputConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceInputConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetOne",
            interface_input_config_request,
            InterfaceInputConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        interface_input_config_some_request: "InterfaceInputConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetSome",
            interface_input_config_some_request,
            InterfaceInputConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAll",
            interface_input_config_stream_request,
            InterfaceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Subscribe",
            interface_input_config_stream_request,
            InterfaceInputConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetMeta",
            interface_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        interface_input_config_stream_request: "InterfaceInputConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeMeta",
            interface_input_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_input_config_set_request: "InterfaceInputConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceInputConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Set",
            interface_input_config_set_request,
            InterfaceInputConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        interface_input_config_set_some_request: "InterfaceInputConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SetSome",
            interface_input_config_set_some_request,
            InterfaceInputConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        interface_input_config_delete_request: "InterfaceInputConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceInputConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.InterfaceInputConfigService/Delete",
            interface_input_config_delete_request,
            InterfaceInputConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        interface_input_config_delete_some_request: "InterfaceInputConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteSome",
            interface_input_config_delete_some_request,
            InterfaceInputConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        interface_input_config_delete_all_request: "InterfaceInputConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteAll",
            interface_input_config_delete_all_request,
            InterfaceInputConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAllBatched",
            interface_input_config_batched_stream_request,
            InterfaceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceInputConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeBatched",
            interface_input_config_batched_stream_request,
            InterfaceInputConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class RevertConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        revert_config_request: "RevertConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RevertConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/GetOne",
            revert_config_request,
            RevertConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        revert_config_some_request: "RevertConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetSome",
            revert_config_some_request,
            RevertConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetAll",
            revert_config_stream_request,
            RevertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/Subscribe",
            revert_config_stream_request,
            RevertConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/GetMeta",
            revert_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        revert_config_stream_request: "RevertConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SubscribeMeta",
            revert_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        revert_config_set_request: "RevertConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RevertConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/Set",
            revert_config_set_request,
            RevertConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        revert_config_set_some_request: "RevertConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SetSome",
            revert_config_set_some_request,
            RevertConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        revert_config_delete_request: "RevertConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "RevertConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.RevertConfigService/Delete",
            revert_config_delete_request,
            RevertConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        revert_config_delete_some_request: "RevertConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/DeleteSome",
            revert_config_delete_some_request,
            RevertConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        revert_config_delete_all_request: "RevertConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/DeleteAll",
            revert_config_delete_all_request,
            RevertConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/GetAllBatched",
            revert_config_batched_stream_request,
            RevertConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["RevertConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.RevertConfigService/SubscribeBatched",
            revert_config_batched_stream_request,
            RevertConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        update_request: "UpdateRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateService/GetOne",
            update_request,
            UpdateResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_some_request: "UpdateSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetSome",
            update_some_request,
            UpdateSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetAll",
            update_stream_request,
            UpdateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/Subscribe",
            update_stream_request,
            UpdateStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateService/GetMeta",
            update_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_stream_request: "UpdateStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/SubscribeMeta",
            update_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_batched_stream_request: "UpdateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/GetAllBatched",
            update_batched_stream_request,
            UpdateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_batched_stream_request: "UpdateBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateService/SubscribeBatched",
            update_batched_stream_request,
            UpdateBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        update_config_request: "UpdateConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/GetOne",
            update_config_request,
            UpdateConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_config_some_request: "UpdateConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetSome",
            update_config_some_request,
            UpdateConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetAll",
            update_config_stream_request,
            UpdateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/Subscribe",
            update_config_stream_request,
            UpdateConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/GetMeta",
            update_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_config_stream_request: "UpdateConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeMeta",
            update_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        update_config_set_request: "UpdateConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/Set",
            update_config_set_request,
            UpdateConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        update_config_set_some_request: "UpdateConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SetSome",
            update_config_set_some_request,
            UpdateConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        update_config_delete_request: "UpdateConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateConfigService/Delete",
            update_config_delete_request,
            UpdateConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        update_config_delete_some_request: "UpdateConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/DeleteSome",
            update_config_delete_some_request,
            UpdateConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        update_config_delete_all_request: "UpdateConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/DeleteAll",
            update_config_delete_all_request,
            UpdateConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/GetAllBatched",
            update_config_batched_stream_request,
            UpdateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeBatched",
            update_config_batched_stream_request,
            UpdateConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class UpdateSyncConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        update_sync_config_request: "UpdateSyncConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateSyncConfigResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetOne",
            update_sync_config_request,
            UpdateSyncConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_some(
        self,
        update_sync_config_some_request: "UpdateSyncConfigSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetSome",
            update_sync_config_some_request,
            UpdateSyncConfigSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAll",
            update_sync_config_stream_request,
            UpdateSyncConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Subscribe",
            update_sync_config_stream_request,
            UpdateSyncConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_meta(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MetaResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetMeta",
            update_sync_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def subscribe_meta(
        self,
        update_sync_config_stream_request: "UpdateSyncConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["MetaResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeMeta",
            update_sync_config_stream_request,
            MetaResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        update_sync_config_set_request: "UpdateSyncConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateSyncConfigSetResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Set",
            update_sync_config_set_request,
            UpdateSyncConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def set_some(
        self,
        update_sync_config_set_some_request: "UpdateSyncConfigSetSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigSetSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SetSome",
            update_sync_config_set_some_request,
            UpdateSyncConfigSetSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete(
        self,
        update_sync_config_delete_request: "UpdateSyncConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "UpdateSyncConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.studio_topology.v1.UpdateSyncConfigService/Delete",
            update_sync_config_delete_request,
            UpdateSyncConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_some(
        self,
        update_sync_config_delete_some_request: "UpdateSyncConfigDeleteSomeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigDeleteSomeResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteSome",
            update_sync_config_delete_some_request,
            UpdateSyncConfigDeleteSomeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def delete_all(
        self,
        update_sync_config_delete_all_request: "UpdateSyncConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteAll",
            update_sync_config_delete_all_request,
            UpdateSyncConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_all_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAllBatched",
            update_sync_config_batched_stream_request,
            UpdateSyncConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["UpdateSyncConfigBatchedStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeBatched",
            update_sync_config_batched_stream_request,
            UpdateSyncConfigBatchedStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DecommissionServiceBase(ServiceBase):

    async def get_one(
        self, decommission_request: "DecommissionRequest"
    ) -> "DecommissionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, decommission_some_request: "DecommissionSomeRequest"
    ) -> AsyncIterator["DecommissionSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator["DecommissionStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator["DecommissionStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, decommission_stream_request: "DecommissionStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, decommission_batched_stream_request: "DecommissionBatchedStreamRequest"
    ) -> AsyncIterator["DecommissionBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, decommission_batched_stream_request: "DecommissionBatchedStreamRequest"
    ) -> AsyncIterator["DecommissionBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DecommissionRequest, DecommissionResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DecommissionSomeRequest, DecommissionSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DecommissionStreamRequest, DecommissionStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DecommissionStreamRequest, DecommissionStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[DecommissionStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[DecommissionStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionBatchedStreamRequest, DecommissionBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionBatchedStreamRequest, DecommissionBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DecommissionService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionRequest,
                DecommissionResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionSomeRequest,
                DecommissionSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                DecommissionStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                DecommissionStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionBatchedStreamRequest,
                DecommissionBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionBatchedStreamRequest,
                DecommissionBatchedStreamResponse,
            ),
        }


class DecommissionConfigServiceBase(ServiceBase):

    async def get_one(
        self, decommission_config_request: "DecommissionConfigRequest"
    ) -> "DecommissionConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, decommission_config_some_request: "DecommissionConfigSomeRequest"
    ) -> AsyncIterator["DecommissionConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator["DecommissionConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator["DecommissionConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, decommission_config_stream_request: "DecommissionConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, decommission_config_set_request: "DecommissionConfigSetRequest"
    ) -> "DecommissionConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, decommission_config_set_some_request: "DecommissionConfigSetSomeRequest"
    ) -> AsyncIterator["DecommissionConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, decommission_config_delete_request: "DecommissionConfigDeleteRequest"
    ) -> "DecommissionConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        decommission_config_delete_some_request: "DecommissionConfigDeleteSomeRequest",
    ) -> AsyncIterator["DecommissionConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        decommission_config_delete_all_request: "DecommissionConfigDeleteAllRequest",
    ) -> AsyncIterator["DecommissionConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
    ) -> AsyncIterator["DecommissionConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        decommission_config_batched_stream_request: "DecommissionConfigBatchedStreamRequest",
    ) -> AsyncIterator["DecommissionConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigRequest, DecommissionConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSomeRequest, DecommissionConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, DecommissionConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, DecommissionConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSetRequest, DecommissionConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigSetSomeRequest, DecommissionConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteRequest, DecommissionConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteSomeRequest, DecommissionConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigDeleteAllRequest, DecommissionConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigBatchedStreamRequest, DecommissionConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DecommissionConfigBatchedStreamRequest, DecommissionConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DecommissionConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigRequest,
                DecommissionConfigResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigSomeRequest,
                DecommissionConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                DecommissionConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                DecommissionConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigSetRequest,
                DecommissionConfigSetResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigSetSomeRequest,
                DecommissionConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DecommissionConfigDeleteRequest,
                DecommissionConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigDeleteSomeRequest,
                DecommissionConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigDeleteAllRequest,
                DecommissionConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigBatchedStreamRequest,
                DecommissionConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DecommissionConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DecommissionConfigBatchedStreamRequest,
                DecommissionConfigBatchedStreamResponse,
            ),
        }


class DeviceInputConfigServiceBase(ServiceBase):

    async def get_one(
        self, device_input_config_request: "DeviceInputConfigRequest"
    ) -> "DeviceInputConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_input_config_some_request: "DeviceInputConfigSomeRequest"
    ) -> AsyncIterator["DeviceInputConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator["DeviceInputConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator["DeviceInputConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_input_config_stream_request: "DeviceInputConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, device_input_config_set_request: "DeviceInputConfigSetRequest"
    ) -> "DeviceInputConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, device_input_config_set_some_request: "DeviceInputConfigSetSomeRequest"
    ) -> AsyncIterator["DeviceInputConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, device_input_config_delete_request: "DeviceInputConfigDeleteRequest"
    ) -> "DeviceInputConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        device_input_config_delete_some_request: "DeviceInputConfigDeleteSomeRequest",
    ) -> AsyncIterator["DeviceInputConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_input_config_delete_all_request: "DeviceInputConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceInputConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceInputConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        device_input_config_batched_stream_request: "DeviceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator["DeviceInputConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigRequest, DeviceInputConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSomeRequest, DeviceInputConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, DeviceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, DeviceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSetRequest, DeviceInputConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigSetSomeRequest, DeviceInputConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteRequest, DeviceInputConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteSomeRequest, DeviceInputConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigDeleteAllRequest, DeviceInputConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigBatchedStreamRequest, DeviceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceInputConfigBatchedStreamRequest, DeviceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DeviceInputConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigRequest,
                DeviceInputConfigResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigSomeRequest,
                DeviceInputConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                DeviceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                DeviceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigSetRequest,
                DeviceInputConfigSetResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigSetSomeRequest,
                DeviceInputConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceInputConfigDeleteRequest,
                DeviceInputConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigDeleteSomeRequest,
                DeviceInputConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigDeleteAllRequest,
                DeviceInputConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigBatchedStreamRequest,
                DeviceInputConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceInputConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceInputConfigBatchedStreamRequest,
                DeviceInputConfigBatchedStreamResponse,
            ),
        }


class DeviceStateServiceBase(ServiceBase):

    async def get_one(
        self, device_state_request: "DeviceStateRequest"
    ) -> "DeviceStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, device_state_some_request: "DeviceStateSomeRequest"
    ) -> AsyncIterator["DeviceStateSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator["DeviceStateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator["DeviceStateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, device_state_stream_request: "DeviceStateStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, device_state_batched_stream_request: "DeviceStateBatchedStreamRequest"
    ) -> AsyncIterator["DeviceStateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, device_state_batched_stream_request: "DeviceStateBatchedStreamRequest"
    ) -> AsyncIterator["DeviceStateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceStateRequest, DeviceStateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[DeviceStateSomeRequest, DeviceStateSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceStateStreamRequest, DeviceStateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceStateStreamRequest, DeviceStateStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[DeviceStateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[DeviceStateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[DeviceStateBatchedStreamRequest, DeviceStateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[DeviceStateBatchedStreamRequest, DeviceStateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.DeviceStateService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceStateRequest,
                DeviceStateResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateSomeRequest,
                DeviceStateSomeResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                DeviceStateStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                DeviceStateStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceStateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateBatchedStreamRequest,
                DeviceStateBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.DeviceStateService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceStateBatchedStreamRequest,
                DeviceStateBatchedStreamResponse,
            ),
        }


class InterfaceInputConfigServiceBase(ServiceBase):

    async def get_one(
        self, interface_input_config_request: "InterfaceInputConfigRequest"
    ) -> "InterfaceInputConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, interface_input_config_some_request: "InterfaceInputConfigSomeRequest"
    ) -> AsyncIterator["InterfaceInputConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator["InterfaceInputConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator["InterfaceInputConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, interface_input_config_stream_request: "InterfaceInputConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, interface_input_config_set_request: "InterfaceInputConfigSetRequest"
    ) -> "InterfaceInputConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self,
        interface_input_config_set_some_request: "InterfaceInputConfigSetSomeRequest",
    ) -> AsyncIterator["InterfaceInputConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, interface_input_config_delete_request: "InterfaceInputConfigDeleteRequest"
    ) -> "InterfaceInputConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        interface_input_config_delete_some_request: "InterfaceInputConfigDeleteSomeRequest",
    ) -> AsyncIterator["InterfaceInputConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_input_config_delete_all_request: "InterfaceInputConfigDeleteAllRequest",
    ) -> AsyncIterator["InterfaceInputConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator["InterfaceInputConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        interface_input_config_batched_stream_request: "InterfaceInputConfigBatchedStreamRequest",
    ) -> AsyncIterator["InterfaceInputConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigRequest, InterfaceInputConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSomeRequest, InterfaceInputConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, InterfaceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, InterfaceInputConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSetRequest, InterfaceInputConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigSetSomeRequest, InterfaceInputConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteRequest, InterfaceInputConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteSomeRequest, InterfaceInputConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigDeleteAllRequest, InterfaceInputConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigBatchedStreamRequest, InterfaceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[InterfaceInputConfigBatchedStreamRequest, InterfaceInputConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigRequest,
                InterfaceInputConfigResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigSomeRequest,
                InterfaceInputConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                InterfaceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                InterfaceInputConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigSetRequest,
                InterfaceInputConfigSetResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigSetSomeRequest,
                InterfaceInputConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceInputConfigDeleteRequest,
                InterfaceInputConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigDeleteSomeRequest,
                InterfaceInputConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigDeleteAllRequest,
                InterfaceInputConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigBatchedStreamRequest,
                InterfaceInputConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.InterfaceInputConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceInputConfigBatchedStreamRequest,
                InterfaceInputConfigBatchedStreamResponse,
            ),
        }


class RevertConfigServiceBase(ServiceBase):

    async def get_one(
        self, revert_config_request: "RevertConfigRequest"
    ) -> "RevertConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, revert_config_some_request: "RevertConfigSomeRequest"
    ) -> AsyncIterator["RevertConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator["RevertConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator["RevertConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, revert_config_stream_request: "RevertConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, revert_config_set_request: "RevertConfigSetRequest"
    ) -> "RevertConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, revert_config_set_some_request: "RevertConfigSetSomeRequest"
    ) -> AsyncIterator["RevertConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, revert_config_delete_request: "RevertConfigDeleteRequest"
    ) -> "RevertConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, revert_config_delete_some_request: "RevertConfigDeleteSomeRequest"
    ) -> AsyncIterator["RevertConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, revert_config_delete_all_request: "RevertConfigDeleteAllRequest"
    ) -> AsyncIterator["RevertConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest"
    ) -> AsyncIterator["RevertConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, revert_config_batched_stream_request: "RevertConfigBatchedStreamRequest"
    ) -> AsyncIterator["RevertConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[RevertConfigRequest, RevertConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigSomeRequest, RevertConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[RevertConfigStreamRequest, RevertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[RevertConfigStreamRequest, RevertConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[RevertConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[RevertConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[RevertConfigSetRequest, RevertConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigSetSomeRequest, RevertConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteRequest, RevertConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteSomeRequest, RevertConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[RevertConfigDeleteAllRequest, RevertConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[RevertConfigBatchedStreamRequest, RevertConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[RevertConfigBatchedStreamRequest, RevertConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.RevertConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigRequest,
                RevertConfigResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigSomeRequest,
                RevertConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                RevertConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                RevertConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigSetRequest,
                RevertConfigSetResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigSetSomeRequest,
                RevertConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                RevertConfigDeleteRequest,
                RevertConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigDeleteSomeRequest,
                RevertConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigDeleteAllRequest,
                RevertConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigBatchedStreamRequest,
                RevertConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.RevertConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                RevertConfigBatchedStreamRequest,
                RevertConfigBatchedStreamResponse,
            ),
        }


class UpdateServiceBase(ServiceBase):

    async def get_one(self, update_request: "UpdateRequest") -> "UpdateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_some_request: "UpdateSomeRequest"
    ) -> AsyncIterator["UpdateSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator["UpdateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator["UpdateStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_stream_request: "UpdateStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, update_batched_stream_request: "UpdateBatchedStreamRequest"
    ) -> AsyncIterator["UpdateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, update_batched_stream_request: "UpdateBatchedStreamRequest"
    ) -> AsyncIterator["UpdateBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[UpdateRequest, UpdateResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self, stream: "grpclib.server.Stream[UpdateSomeRequest, UpdateSomeResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, UpdateStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, UpdateStreamResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[UpdateStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateBatchedStreamRequest, UpdateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateBatchedStreamRequest, UpdateBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateRequest,
                UpdateResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSomeRequest,
                UpdateSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                UpdateStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                UpdateStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateBatchedStreamRequest,
                UpdateBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateBatchedStreamRequest,
                UpdateBatchedStreamResponse,
            ),
        }


class UpdateConfigServiceBase(ServiceBase):

    async def get_one(
        self, update_config_request: "UpdateConfigRequest"
    ) -> "UpdateConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_config_some_request: "UpdateConfigSomeRequest"
    ) -> AsyncIterator["UpdateConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator["UpdateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator["UpdateConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_config_stream_request: "UpdateConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, update_config_set_request: "UpdateConfigSetRequest"
    ) -> "UpdateConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, update_config_set_some_request: "UpdateConfigSetSomeRequest"
    ) -> AsyncIterator["UpdateConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, update_config_delete_request: "UpdateConfigDeleteRequest"
    ) -> "UpdateConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self, update_config_delete_some_request: "UpdateConfigDeleteSomeRequest"
    ) -> AsyncIterator["UpdateConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, update_config_delete_all_request: "UpdateConfigDeleteAllRequest"
    ) -> AsyncIterator["UpdateConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self, update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest"
    ) -> AsyncIterator["UpdateConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self, update_config_batched_stream_request: "UpdateConfigBatchedStreamRequest"
    ) -> AsyncIterator["UpdateConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[UpdateConfigRequest, UpdateConfigResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSomeRequest, UpdateConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[UpdateConfigStreamRequest, UpdateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[UpdateConfigStreamRequest, UpdateConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self, stream: "grpclib.server.Stream[UpdateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self, stream: "grpclib.server.Stream[UpdateConfigStreamRequest, MetaResponse]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSetRequest, UpdateConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigSetSomeRequest, UpdateConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteRequest, UpdateConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteSomeRequest, UpdateConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[UpdateConfigDeleteAllRequest, UpdateConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateConfigBatchedStreamRequest, UpdateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateConfigBatchedStreamRequest, UpdateConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigRequest,
                UpdateConfigResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigSomeRequest,
                UpdateConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                UpdateConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                UpdateConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigSetRequest,
                UpdateConfigSetResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigSetSomeRequest,
                UpdateConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateConfigDeleteRequest,
                UpdateConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigDeleteSomeRequest,
                UpdateConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigDeleteAllRequest,
                UpdateConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigBatchedStreamRequest,
                UpdateConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateConfigBatchedStreamRequest,
                UpdateConfigBatchedStreamResponse,
            ),
        }


class UpdateSyncConfigServiceBase(ServiceBase):

    async def get_one(
        self, update_sync_config_request: "UpdateSyncConfigRequest"
    ) -> "UpdateSyncConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_some(
        self, update_sync_config_some_request: "UpdateSyncConfigSomeRequest"
    ) -> AsyncIterator["UpdateSyncConfigSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator["UpdateSyncConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator["UpdateSyncConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_meta(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> "MetaResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_meta(
        self, update_sync_config_stream_request: "UpdateSyncConfigStreamRequest"
    ) -> AsyncIterator["MetaResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, update_sync_config_set_request: "UpdateSyncConfigSetRequest"
    ) -> "UpdateSyncConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set_some(
        self, update_sync_config_set_some_request: "UpdateSyncConfigSetSomeRequest"
    ) -> AsyncIterator["UpdateSyncConfigSetSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, update_sync_config_delete_request: "UpdateSyncConfigDeleteRequest"
    ) -> "UpdateSyncConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_some(
        self,
        update_sync_config_delete_some_request: "UpdateSyncConfigDeleteSomeRequest",
    ) -> AsyncIterator["UpdateSyncConfigDeleteSomeResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, update_sync_config_delete_all_request: "UpdateSyncConfigDeleteAllRequest"
    ) -> AsyncIterator["UpdateSyncConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
    ) -> AsyncIterator["UpdateSyncConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe_batched(
        self,
        update_sync_config_batched_stream_request: "UpdateSyncConfigBatchedStreamRequest",
    ) -> AsyncIterator["UpdateSyncConfigBatchedStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigRequest, UpdateSyncConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSomeRequest, UpdateSyncConfigSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_some,
            stream,
            request,
        )

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, UpdateSyncConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, UpdateSyncConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_get_meta(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_meta(request)
        await stream.send_message(response)

    async def __rpc_subscribe_meta(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigStreamRequest, MetaResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_meta,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSetRequest, UpdateSyncConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_set_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigSetSomeRequest, UpdateSyncConfigSetSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.set_some,
            stream,
            request,
        )

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteRequest, UpdateSyncConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_some(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteSomeRequest, UpdateSyncConfigDeleteSomeResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_some,
            stream,
            request,
        )

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigDeleteAllRequest, UpdateSyncConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    async def __rpc_get_all_batched(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigBatchedStreamRequest, UpdateSyncConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all_batched,
            stream,
            request,
        )

    async def __rpc_subscribe_batched(
        self,
        stream: "grpclib.server.Stream[UpdateSyncConfigBatchedStreamRequest, UpdateSyncConfigBatchedStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_batched,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigRequest,
                UpdateSyncConfigResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetSome": grpclib.const.Handler(
                self.__rpc_get_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigSomeRequest,
                UpdateSyncConfigSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                UpdateSyncConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                UpdateSyncConfigStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetMeta": grpclib.const.Handler(
                self.__rpc_get_meta,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeMeta": grpclib.const.Handler(
                self.__rpc_subscribe_meta,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigStreamRequest,
                MetaResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigSetRequest,
                UpdateSyncConfigSetResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SetSome": grpclib.const.Handler(
                self.__rpc_set_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigSetSomeRequest,
                UpdateSyncConfigSetSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateSyncConfigDeleteRequest,
                UpdateSyncConfigDeleteResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteSome": grpclib.const.Handler(
                self.__rpc_delete_some,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigDeleteSomeRequest,
                UpdateSyncConfigDeleteSomeResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigDeleteAllRequest,
                UpdateSyncConfigDeleteAllResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/GetAllBatched": grpclib.const.Handler(
                self.__rpc_get_all_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigBatchedStreamRequest,
                UpdateSyncConfigBatchedStreamResponse,
            ),
            "/arista.studio_topology.v1.UpdateSyncConfigService/SubscribeBatched": grpclib.const.Handler(
                self.__rpc_subscribe_batched,
                grpclib.const.Cardinality.UNARY_STREAM,
                UpdateSyncConfigBatchedStreamRequest,
                UpdateSyncConfigBatchedStreamResponse,
            ),
        }
